udho provides varying types of servers depending on the logging and session facilities. A server is called stateful if it provides HTTP session, otherwise it is called stateless. If the server provides APIs that do noy require any session then use stateless server, otherwise use a stateful server. If no logging is required then use a `quiet` server that uses a void logger, otherwise use a logging server. The servers `udho::servers::ostreamed::stateless` and `udho::servers::ostreamed::stateful<>` used in the examples are stateless and stateful servers respectively that uses ostreamed logger present inside udho. All servers inside `udho::servers` namespace are typedef'ed `udho::server`.

### Logged Stateless Server

```cpp
udho::servers::stateless::logged<LoggerT>
udho::servers::logged<LoggerT>::stateless
```

### Quiet Stateless Server

```cpp
udho::servers::stateless::quiet
udho::servers::quiet::stateless
```

### Logged Stateful Server

```cpp
udho::servers::stateful<States...>::logged<LoggerT>
udho::servers::logged<LoggerT>::stateful<States...>
```

### Quiet Stateful Server

```cpp
udho::servers::stateful<States...>::quiet
udho::servers::quiet::stateful<States...>
```

udho comes with a logger `udho::loggers::ostream` that prints logginf messages to `std::ostream`. This logger is used in all examples. So there is a typedef `servers::stateful<States...>::ostreamed` that actually is `servers::stateful<States...>::logged<loggers::ostream>`

A Logging server takes reference to a logger in constructor. So the Logger has to be instantiated by the caller, as shown in the following example.

```cpp
udho::loggers::ostream logger(std::cout);
udho::servers::stateful<StateA, StateB>::ostreamed server(logger);
```

For ease of access there is an `ostreamed` server is provided which owns the ostream logger inside. To use this server, no logger has to be instantiated. Only the stream (std::cout) has to be provided. through the constructor.

```cpp
udho::servers::ostreamed::stateless
udho::servers::ostreamed::stateful<StateA, StateB>
```


## Composition 

udho server takes a `LoggerT` and a `CacheT` as template parameters. The `LoggerT` provides logging facilities and the `CacheT` serves as the HTTP session. the first parameter `udho::bridge` bridges a server with the contexts. It provides utilities like document root, that are configured at the server to the callable's context. The reference to the bridge can be accessed through `aux()` method in the context.

```cpp
typedef server<udho::bridge, LoggerT, CacheT> server_type;
```

The cache is implemented by the template `udho::cache::store<KeyT, States...>`. The `cache::store` serves as a key-value store where the set of possible values are limited by the variadic parameter `States...`. 

```cpp
struct X{};
struct Y{};
struct Z{};
udho::cache::store<int, X, X, Z> store;
```

In the example above an integer indexed `store` is created that can store only three types of values (`X`, `Y`, `Z`) for each key. Any read or write opration using any type other than these three will be restricted at compile time. The operations that can be performed on the store are 

> #### bool exists<V\>(const KeyT& key)
> checks for existance of any value of type `V` against the `key`
> #### V get(const KeyT& key, const V& default_value)
> gets the value of type `V` associated with the `key`. If no such value is inserted returns the `default_value`
> #### V at<V\>(const KeyT& key)
> returns the value of type `V` associated with `key` and throws exception if that doesn't exist.
> #### void insert(const KeyT& key, const V& value)
> associates a value of type `V` with `key`

udho uses `boost::uuids::uuid` as `KeyT`to provide session id. So each session id is 128 bit uuid generated by boost uuid library.