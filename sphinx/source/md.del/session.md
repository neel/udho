udho server takes a `LoggerT` and a `CacheT` as template parameters. The `LoggerT` provides logging facilities and the `CacheT` serves as the HTTP session. the first parameter `udho::bridge` bridges a server with the contexts. It provides utilities like document root, that are configured at the server to the callable's context. The reference to the bridge can be accessed through `aux()` method in the context.

```cpp
typedef server<udho::bridge, LoggerT, CacheT> server_type;
```

The cache is implemented by the template `udho::cache::store<KeyT, States...>`. The `cache::store` serves as a key-value store where the set of possible values are limited by the variadic parameter `States...`. 

```cpp
struct X{};
struct Y{};
struct Z{};
udho::cache::store<int, X, X, Z> store;
```

In the example above an integer indexed `store` is created that can store only three types of values (`X`, `Y`, `Z`) for each key. Any read or write opration using any type other than these three will be restricted at compile time. The operations that can be performed on the store are 

> #### bool exists<V\>(const KeyT& key)
> checks for existance of any value of type `V` against the `key`
> #### V get(const KeyT& key, const V& default_value)
> gets the value of type `V` associated with the `key`. If no such value is inserted returns the `default_value`
> #### V at<V\>(const KeyT& key)
> returns the value of type `V` associated with `key` and throws exception if that doesn't exist.
> #### void insert(const KeyT& key, const V& value)
> associates a value of type `V` with `key`

udho uses `boost::uuids::uuid` as `KeyT`to provide session id. So each session id is 128 bit uuid generated by boost uuid library.